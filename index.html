<!DOCTYPE html>
<html>
<head>
  <title>3D Game - First Person POV</title>
  <style>
    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    body {
      overflow: hidden;
      margin: 0;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 237px; /* Adjust the width and height as needed */
      height: 180px;
      background-image: url("Shotty.png"); /* Replace with the path to your overlay image */
      background-size:cover;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!div id="overlay"></div>
  </div>

  <script src="three.js"></script>
  <script>
    // Create the scene
    const scene = new THREE.Scene();
    const r = -Math.PI/2;

    // Create the camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 0); // Set initial camera position
    camera.rotation.y = r-0.75;

    // Create the renderer
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x87ceeb); // Set the background color to sky blue
    document.getElementById('game-container').appendChild(renderer.domElement);

    // Create a flat ground plane
    const squareSize = 1; // Size of each square in the checkerboard pattern
    const numSquares = 10; // Number of squares per side
    const lightGreyColor = 0xd3d3d3; // Light grey color

    const groundGeometry = new THREE.Geometry();

    // Create vertices and faces for each square
    for (let i = 0; i < numSquares; i++) {
      for (let j = 0; j < numSquares; j++) {
        const z = i * squareSize;
        const x = j * squareSize;

        const square = new THREE.PlaneGeometry(squareSize, squareSize);
        const squareMaterial = new THREE.MeshBasicMaterial({
          vertexColors: THREE.VertexColors
        });

        // Set colors for each vertex of the square
        for (let k = 0; k < square.faces.length; k++) {
          const color1 = new THREE.Color(lightGreyColor);
          const face = square.faces[k];
          
          if (k % 2 === 0) {
            face.vertexColors[0] = color1;
            face.vertexColors[1] = color1;
            face.vertexColors[2] = color1;
          }
        }

        const squareMesh = new THREE.Mesh(square, squareMaterial);
        squareMesh.position.set(x, 0, z);
        squareMesh.rotation.x = 1*r; // Rotate the square to be flat
        squareMesh.updateMatrix();

        groundGeometry.merge(squareMesh.geometry, squareMesh.matrix);
      }
    }

    const groundMaterial = new THREE.MeshBasicMaterial({
      vertexColors: THREE.VertexColors
    });

    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    scene.add(ground);

    // Handle keyboard input for camera movement
    const keyboard = {};
    document.addEventListener('keydown', (event) => {
      keyboard[event.code] = true;
    });
    document.addEventListener('keyup', (event) => {
      keyboard[event.code] = false;
    });

    // Update the overlay content
    function updateOverlay() {
      const overlay = document.getElementById('overlay');
      overlay.textContent = 'This is an overlay';
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Handle camera movement
      const moveSpeed = 0.1;
      const rotateAngle = camera.rotation.y;

      if (keyboard['KeyW']) {
        camera.position.z -= moveSpeed * Math.cos(rotateAngle);
        camera.position.x -= moveSpeed * Math.sin(rotateAngle);
      }
      if (keyboard['KeyS']) {
        camera.position.z += moveSpeed * Math.cos(rotateAngle);
        camera.position.x += moveSpeed * Math.sin(rotateAngle);
      }
      if (keyboard['KeyA']) {
        camera.position.z += moveSpeed * Math.sin(rotateAngle);
        camera.position.x -= moveSpeed * Math.cos(rotateAngle);
      }
      if (keyboard['KeyD']) {
        camera.position.z -= moveSpeed * Math.sin(rotateAngle);
        camera.position.x += moveSpeed * Math.cos(rotateAngle);
      }

      const RotateSpeed = 0.05;
      if (keyboard['ArrowLeft']) camera.rotation.y += RotateSpeed;
      if (keyboard['ArrowRight']) camera.rotation.y -= RotateSpeed

      // Update the overlay

      
      // Render the scene
      renderer.render(scene, camera);
    }

    // Start the animation loop
    animate();
  </script>
</body>
</html>